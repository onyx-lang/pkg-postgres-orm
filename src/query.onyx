package postgres.orm

use core

// @Cleanup
// There are many procedures in this file that should be made
// into macros; however, because of the current macro rules,
// the procedures behave incorrectly.
//
// To describe the problem briefly, macro parameters are currently
// achieved using symbol substitution for an expression. This
// presents a problem when the expression is not a simple local variable.
// When the symbol is expanded, the whole expression is placed again,
// meaning it will be evaluated every time it is used.
//
// This is a problem for this code, because the query parameter (q) is
// usually given as a complicated expression involving other macro
// expansions.
//
// When this compiler bug (or feature?) is fixed, this code should be
// made to use macros.
//

Query :: struct (table_type: type_expr) {
    builder: ^QueryBuilder;
}

#inject
ORMContext.query :: macro (ctx: ^ORMContext, $type: type_expr) -> Query(type) {
    Query :: Query
    QueryBuilder :: QueryBuilder

    q: Query(type);
    q.builder = new(QueryBuilder, allocator=ctx.allocator);
    q.builder->init(type, ctx);
    return q;
}

#inject
Query.filter :: #match #local {}

#overload
Query.filter :: (q: Query, filter: str) => {
    q.builder->filter(filter);
    return q;
}

#overload
Query.filter :: (q: Query, filter_format: str, values: [] any) => {
    q.builder->filter(filter_format, values);
    return q;
}

// @Cleanup  make this a macro when macros support any
#overload #precedence 2
Query.filter :: (q: Query, filter_format: str, values: ..any) => {
    q.builder->filter(filter_format, values);
    return q;
}


#inject
Query.order :: (q: Query, field: str, ord: QueryOrdering) => {
    q.builder->order(field, ord);
    return q;
}


#inject
Query.group :: #match #local {}

#overload
Query.group :: (q: Query, group: str) => {
    q.builder->group(group);
    return q;
}

// @Cleanup
#overload
Query.group :: (q: Query, group_format: str, values: .. any) => {
    q.builder->group(group_format, values);
    return q;
}


#inject
Query.limit :: macro (q: Query, limit: u32) => {
    q.builder.limit = limit;
    return q;
}

#inject
Query.offset :: macro (q: Query, offset: u32) => {
    q.builder.offset = offset;
    return q;
}


#inject
Query.all :: (q: Query) -> [] ^q.table_type {
    return ~~ q.builder->all();
}

#inject
Query.first :: (q: Query) -> ^q.table_type {
    return ~~ q.builder->first();
}

#inject
Query.find :: (q: Query, key: any) -> ^q.table_type {
    return ~~ q.builder->find(key);
}

#inject
Query.delete :: (q: Query) -> i32 {
    return q.builder->delete();
}

#inject
Query.update :: (q: Query, field: str, value: any) -> i32 {
    return q.builder->update(field, value);
}



